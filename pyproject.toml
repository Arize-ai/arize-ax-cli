[project]
name = "arize-ax-cli"
description = "Official Arize CLI tool for managing datasets, experiments, and more"
readme = "README.md"
requires-python = ">=3.11"
license = { text = "Apache-2.0" }
authors = [
    { name = "Arize AI", email = "support@arize.com" }
]
keywords = ["arize", "cli", "machine-learning", "mlops", "llm", "observability"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: Apache Software License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "Programming Language :: Python :: 3.14",
    "Topic :: Software Development :: Libraries :: Python Modules",
]
dynamic = ["version"]
dependencies = [
    "arize>=8.0.0b0, <9",
    "pydantic>=2.0.0, <3",
    "questionary>=2.0.0, <3",
    "rich>=13.0.0, <14",
    "shellingham>=1.5.0, <2",  # For shell detection in completion
    "tomli-w>=1.0.0, <2",  # For TOML writing
    "typer>=0.12.0, <1",
]

[project.optional-dependencies]
dev = [
    "mypy==1.19.1",
    "pandas-stubs>=2.2.0",
    "pytest-cov==6.0.0",
    "pytest==8.4.2",
    "ruff==0.14.9",
    "taskipy>=1.14.1, <2",
]

[project.urls]
Homepage = "https://arize.com"
Documentation = "https://docs.arize.com/cli"
Repository = "https://github.com/Arize-ai/ax-cli"
"Bug Tracker" = "https://github.com/Arize-ai/ax-cli/issues"

[project.scripts]
ax = "ax.cli:app"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.version]
path = "src/ax/version.py"

[tool.hatch.build]
only-packages = true

[tool.hatch.build.targets.wheel]
packages = ["src/ax"]

[tool.hatch.build.targets.sdist]
exclude = ["tests", "docs"]

[tool.ruff]
target-version = "py310"
line-length = 80
exclude = [
    "dist/",
    "testing_notebooks/",
    "__pycache__",
    "src/arize/_generated/**/*.py",
    "*_pb2.py*",
    "*_pb2_grpc.py*",
    "*.pyi",
    "docs/",
]
[tool.ruff.format]
docstring-code-format = true
line-ending = "native"

[tool.ruff.lint]
select = [
    # Core correctness & style
    # ------------------------
    "E",   # pycodestyle errors (syntax, indentation, whitespace)
    "W",   # pycodestyle warnings (less severe style issues)
    "F",   # Pyflakes (unused imports, undefined names, etc.)
    "UP",  # pyupgrade (modernize syntax for your Python version)
    "B",   # flake8-bugbear (likely bugs and design problems)
    "SIM", # flake8-simplify (simpler / clearer code patterns)
    "I",   # isort (import ordering)

    # Typing & documentation
    # ------------------------
    "ANN", # flake8-annotations (enforce type annotations)
    "D",   # pydocstyle (docstring conventions for public APIs)
    "TCH", # flake8-type-checking (TYPE_CHECKING import hygiene)

    # Recommended for SDKs
    # ------------------------
    "RUF",  # Ruff-native rules (high-signal correctness & footguns)
    "C4",   # flake8-comprehensions (cleaner comprehensions)
    "PIE",  # flake8-pie (small correctness & readability improvements)
    "PERF", # perflint (common performance pitfalls)
    "DTZ",  # flake8-datetimez (timezone-aware datetime usage)
    "TRY",  # tryceratops (better exception handling patterns)
    "RET",  # flake8-return (return consistency)
    "S",    # flake8-bandit (basic security issues; tune via ignores)
]
ignore = [
    "TRY003", # Put long / detailed messages inside the exception class
    "D100",   # Missing docstring in public module
]

[tool.ruff.lint.per-file-ignores]
"tests/**/*.py" = [
    "D104",   # Missing docstring in public package
    "DTZ001", # Allow naive datetime usage in tests
    "S101",   # Allow assert statements in tests
    "S108",   # Allow insecure usage of temporary file or directory
    "TRY301", # Allow generic exception catching in tests
]

[tool.ruff.lint.isort]
force-wrap-aliases = true

[tool.ruff.lint.pycodestyle]
max-doc-length = 110
max-line-length = 110

[tool.ruff.lint.pydocstyle]
convention = "google"

[tool.ruff.lint.pyupgrade]
keep-runtime-typing = true

# Ignore missing imports for libraries without type stubs
[tool.mypy]
python_version = "3.12"
warn_unused_configs = true
exclude = ["testing_notebooks/", "src/arize/_generated/", "tests/"]
# Incrementally enable strict type checking by uncommenting checks from bottom to top.
# Fix foundational issues (imports, syntax) before type definitions, then signatures, then implementations.
disable_error_code = []

# Ignore missing imports for libraries without type stubs
[[tool.mypy.overrides]]
module = [
    "pyarrow.*",
    "google.protobuf.*",
    "wrapt.*",
    "requests_futures.*",
    "interpret_community.*",
    "sklearn.*",
]
ignore_missing_imports = true

[tool.pytest.ini_options]
# Directory where pytest will search for tests
testpaths = ["tests"]
# Patterns for discovering test files (files matching these patterns will be collected)
python_files = ["test_*.py", "*_test.py"]
# Patterns for discovering test classes (classes matching this pattern will be collected)
python_classes = ["Test*"]
# Patterns for discovering test functions (functions matching this pattern will be collected)
python_functions = ["test_*"]
# Directories and patterns to ignore during test collection
norecursedirs = [
    ".*",
    "build",
    "dist",
    "*.egg"
]
# Additional command-line options to always apply when running pytest
addopts = [
    "-v",               # Verbose: show individual test names as they run
    "--strict-markers", # Error on undefined markers (prevents typos like @pytest.mark.slo instead of @pytest.mark.slow)
    "--tb=short",       # Shorter tracebacks: show only the failure point without full stack
    "--durations=10",   # Show the 10 slowest tests at the end (helps identify performance bottlenecks)
]
# Custom markers that can be used to categorize tests (use with @pytest.mark.marker_name)
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "integration: marks tests as integration tests",
    "unit: marks tests as unit tests",
]

[tool.coverage.run]
source = ["src/ax"]
omit = [
    "*/tests/*",
    "*/_generated/*",
    "*/__pycache__/*",
    "*/site-packages/*",
]
# Enable branch coverage (measures whether all branches of if/else/try/except are tested)
# Without this, only line coverage is measured
branch = true

[tool.coverage.report]
# Number of decimal places to show in coverage percentages (e.g., 85.47% instead of 85%)
precision = 2
# Show line numbers for lines that are missing coverage in the report
show_missing = true
# If true, files with 100% coverage would be hidden from the report
skip_covered = false
# Minimum coverage percentage required (build fails if total coverage is below this)
fail_under = 0
# Lines matching these patterns are excluded from coverage measurement
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "raise AssertionError",
    "raise NotImplementedError",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
    "@abstractmethod",
    "@abc.abstractmethod",
]

[tool.coverage.html]
# Directory where HTML coverage reports will be generated (browsable in a web browser)
directory = "htmlcov"

[tool.taskipy.tasks]
lint = { cmd = "ruff format . && ruff check --fix .", cwd = ".", help = "Run ruff to format and lint the package." }
type-check = {cmd = "mypy --no-incremental --show-traceback --config-file pyproject.toml .", cwd = ".", help = "Run mypy for type checking."}
test = {cmd = "pytest --cov .", cwd = ".", help = "Run the test suite with coverage."}
# Exclusive for CI
ci-format = { cmd = "ruff format --check .", cwd = ".", help = "Run ruff to check formatting of the package during CI." }
ci-lint = { cmd = "ruff check .", cwd = ".", help = "Run ruff to check linting rules of the package during CI." }
ci-type-check = {cmd = "mypy --no-incremental --show-traceback --config-file pyproject.toml .", cwd = ".", help = "Run mypy for type checking during CI."}
ci-test = {cmd = "pytest --cov --cov-report=term-missing --cov-report=html .", cwd = ".", help = "Run the test suite with coverage during CI."}
